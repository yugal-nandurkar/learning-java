Explanation of Functional Interfaces
Function

Takes one argument of type T and returns a result of type R.
Example: Function<String, Integer> converts a string to its length.
Consumer

Takes one argument of type T and performs an action (side effect), but doesn't return a result.
Example: Consumer<String> prints the input string.
Supplier

Takes no arguments and provides a result of type T.
Example: Supplier<Double> generates a random number.
Predicate

Takes one argument of type T and returns a boolean.
Example: Predicate<Integer> checks if an integer is even.
BiFunction

Takes two arguments of types T and U, and returns a result of type R.
Example: BiFunction<Integer, Integer, Integer> adds two integers.
BinaryOperator

A specialized version of BiFunction for cases where the arguments and the result are of the same type.
Example: BinaryOperator<Integer> multiplies two integers.
UnaryOperator

A specialized version of Function for cases where the input and output types are the same.
Example: UnaryOperator<String> converts a string to uppercase.
Sample Output
When you run the application, the console output will look like this:

text
Copy code
Length of 'Spring': 6
Hello, Consumer!
Random Number: 0.43892110893616874
Is 4 even? true
Sum of 5 and 3: 8
Product of 6 and 4: 24
Uppercase 'spring': SPRING
This implementation showcases the practical usage of functional interfaces within the context of a Spring Boot application.